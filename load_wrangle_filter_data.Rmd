---
title: "Loading, Wrangling, & Filtering Data"
author: "Rose Evard"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    df_print: paged
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
```

```{r}

library(tidyverse)
library(xml2)
library(kableExtra)
library(lubridate)
library(forcats)
```


# Generate Metadata Table for All Files  
```{r get_df function for extracting data from xml files,eval=TRUE, class.source = "fold-show" }


##########################################################
# ITERATE THROUGH ALL FILES AND EXTRACT GIVEN VARIABLES
##########################################################


#' @param variables character vector of variables to extract from the xml files
#' @param filename string containing full path to xml file to be read
#' @param include_paths logical; whether to include paths to extracted variables in data frame

get_df <- function(variables,
                   filename, 
                   include_paths = TRUE) {
  
  # create column names with just the variables (no paths)
  variables_no_path <- gsub("*.*\\/", "", variables )
  
  xml_file <- read_xml(filename)
  xml_file <- xml_ns_strip(xml_file)
  
  # extract each variable; if it isn't present, put NA 
  extracted <- map(variables, ~{
    value <- xml_find_all(
      xml_file, 
      xpath =.x)
    value <- ifelse(length(value) ==0, 
                    NA, 
                    xml_text(value)) })
  
   names(extracted) <- variables_no_path
   
   extracted <- extracted %>%
     as_tibble()
 
 
   # add columns with the paths to each variable within the xml file
   if(include_paths) {
      paths <- map(variables, ~ {
        value <- xml_find_all(
          xml_file, 
          xpath = paste0(.x)) 
         value <- ifelse(length(value) ==0, 
                      NA, 
                      xml_path(value)) })
      
      names(paths) <- paste0(variables_no_path, "_path")
      
      extracted <- extracted %>%
        bind_cols(as_tibble(paths)) 
  
   }
    
   # check how many of the entries are NA
   # if all NA, prefix 'irs:' may be needed
   columns_not_na <- map_dbl(as.data.frame(extracted), ~!is.na(.x)) %>% sum()
   
   # handle case where prefix 'irs' is in front
   if(columns_not_na == 0){
     
       extracted <- map(variables_no_path, ~ {
        value <- xml_find_all(xml_file, 
                              xpath = paste0("//irs:", .x)) 
        value <- ifelse(length(value) ==0, 
                    NA, 
                    xml_text(value)) })
        names(extracted) <- variables_no_path
        
         extracted <- extracted %>%
           as_tibble()
     
        if(include_paths) {
        paths <- map(variables_no_path, ~ {
          value <- xml_find_all(
            xml_file, 
            xpath = paste0("//irs:", .x))
      
          value <- ifelse(length(value) ==0, 
                      NA, 
                      xml_path(value)) })
        
        names(paths) <- paste0(variables_no_path, "_path")  
        
      extracted <-  extracted %>%
        bind_cols(as_tibble(paths)) 
     }
   }
   
 # add name of file to data frame
 extracted %>%
   mutate(filename = gsub("*.*\\/", "", filename))
}
```

```{r}


# Reference for Field Names
# https://vtechworks.lib.vt.edu/bitstream/handle/10919/109974/TaxDataFinalReport.pdf?sequence=10&isAllowed=y

# path assumes zip-file is unzipped in smith-capstone-23 directory
# generates vector of the full paths to all files in the ballet_990_released_20230208 directory
files <- dir( "./ballet_990_released_20230208",
              full.names = TRUE)

# variables to extract from each xml file
variables_to_extract <- c("//Return//ReturnHeader//ReturnTs",  
                          "//Return//ReturnHeader//Filer//EIN", 
                          "//Return//ReturnHeader//ReturnTypeCd",
                          "//Return//ReturnHeader//TaxPeriodBeginDt",
                          "//Return//ReturnHeader//TaxPeriodEndDt",
                          "//AmendedReturnInd",
                          "//Return//ReturnHeader//BusinessName")


# if data directory does not exist in current directory, create it 
if(!file.exists("./data")) {dir.create("./data")}

# iterate over all xml files in the directory and extract data
# each iteration generates one row of the data frame
all_data <- map_df(files, ~
                     get_df(variables = variables_to_extract,
                     filename = .x)) 

# clean timestamp and dates
# fiscal year is defined as the year of TaxPeriodEndDt
all_data <- all_data %>%
  mutate(ReturnDate = as.Date(ReturnTs,
                              format = "%Y-%m-%d")) %>%
  mutate(across(c(TaxPeriodBeginDt, 
                  TaxPeriodEndDt),
                as.Date, 
                format = "%Y-%m-%d")) %>%
  mutate(fiscal_year = year(TaxPeriodEndDt),
         fiscal_year = factor(fiscal_year),
         BusinessName = toupper(BusinessName))

# check all files are present in data frame
# nrow(all_data) == length(files)

# save RDS file to data directory
saveRDS(all_data, "./data/data_990.RDS")

```


