---
title: "Endowment Data: Taking Most Recent Data Available"
author: "Quinn White"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    df_print: paged
    code_folding: show
    css: !expr here::here('css', 'template.css')
    toc_depth: 4
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_dir = "output_html")})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE,warning=FALSE)
library(tidyverse)
library(here)
```


```{r}

# needed for variable extraction 
source(here('GET_VARS.R'))


```

# Extract All Schedule D Variables

```{r}
files <- dir(here("ballet_990_released_20230208"),
              full.names = TRUE)

# get data frame with all schedule D variables 
all_sched_d <- map_df(files, ~get_df(
  filename = .x, 
  schedule = 'd')) %>%
  # only take amended filings
  filter_ein() %>%
  mutate(fiscal_year = as.numeric(paste(fiscal_year)))



# select variables that have data across multiple years
endowment <- all_sched_d %>%
    rename_with(~gsub("/Return/ReturnData/IRS990ScheduleD/", "", .)) %>%
  # contains CY or Minus
  select(fiscal_year, EIN, matches("CY|Minus", ignore.case= FALSE)) %>%
  # these are higher level variables in the nested structure, we want to be 
  # working with variables contained in these nodes
  select(-c(CYEndwmtFundGrp,
            CYMinus1YrEndwmtFundGrp,
            CYMinus2YrEndwmtFundGrp,
            CYMinus3YrEndwmtFundGrp,
            CYMinus4YrEndwmtFundGrp)) %>%
  # rename to CM* using the same formatting as we have throughout the project
  rename_with(~gsub("EndwmtFundGrp/|inus|Yr", "", .)) %>%
  mutate(across( matches("CY"), as.numeric)) 
  

# endowment variables that do not have data across multiple years
add_vars <- all_sched_d %>%
  select(fiscal_year, EIN, contains("end")) %>%
  select(fiscal_year, EIN, !matches("CY|Minus", ignore.case= FALSE))  %>%
  rename_with(~gsub("/Return/ReturnData/IRS990ScheduleD/", "", .))  %>%
  mutate(across(contains("Pct"), as.numeric))


  

```

# Check Which Variables Have Data Across Multiple Years

```{r}

# base names of variables of interest
base_names <- colnames(endowment) %>% 
  gsub('CY|CYM1|CYM2|CYM3|CYM4', '', .) %>%
  unique() 

base_names <- base_names[!base_names %in% c("EIN", "fiscal_year")]

```

# Use Most Recent Data Available 

```{r}

# for a given base name of the variable, for each fiscal year, takes the most 
# recently available value
get_most_recent <- function(endowment_df, base_name) {
  endowment_df %>%
    select(EIN, fiscal_year, contains(base_name)) %>%
    # make sure each has every fiscal years with NAs for fiscal years that are missing
     pivot_wider(names_from = fiscal_year, 
                 values_from=contains(base_name)) %>%
     pivot_longer(cols = contains(base_name),
                  names_to = "variable_year") %>%
     separate(variable_year, sep = "_", into = c("variable_name", "fiscal_year")) %>%
      mutate(fiscal_year = as.integer(fiscal_year)) %>%
      mutate(value_year = case_when(
       variable_name == paste0("CY", base_name) ~ fiscal_year,
       variable_name == paste0("CYM1", base_name) ~ fiscal_year -1,
       variable_name == paste0("CYM2", base_name) ~ fiscal_year -2,
       variable_name == paste0("CYM3", base_name) ~ fiscal_year -3,
       variable_name == paste0("CYM4", base_name) ~ fiscal_year -4),
       source = ifelse(grepl("CYM", variable_name), 
                       substr(variable_name, 1,4), 
                       "CY"),
       source = paste0(source, fiscal_year)) %>%
          filter(!is.na(value)) %>%
      group_by(EIN, value_year) %>%
      slice_max(n = 1, order_by = fiscal_year)%>% 
      ungroup() %>%
      mutate(variable_name = base_name,
             year = value_year,
             value,
             # assignment operator := needed when we use !! on the left side of an assigment
             name = !!base_name) %>%
    select(EIN, fiscal_year = year, source, value, name)

}

```

# Check Results are Concordant with Those from `get_df` Except in Cases Where the EIN has a Discrepancy 

```{r}


# iterate over each variable of interest 
endowment_recent <- map_df(base_names,
       ~get_most_recent(endowment, base_name = .x))


endowment_recent_long <- endowment_recent %>% 
  mutate(version = "recent") %>%
  select(-source)


# check correspondence with data frame extracted *without* accounting for discrepancies
end_original <- endowment %>%
  select(fiscal_year, EIN, paste0("CY", base_names)) %>%
  pivot_longer(-c(fiscal_year,EIN)) %>%
  mutate(name = gsub("CY", '', name)) %>%
  mutate(fiscal_year = as.numeric(paste(fiscal_year))) %>%
  mutate(version = "original")

# read vector of EINS that had discordant values
eins_discord <- readRDS(here("data", "discordant_EINS.RDS"))

# test that only eins where there is a difference is in those with discrepancies
testthat::expect_equal( { endowment_recent_long %>%
  bind_rows(end_original) %>%
  # group_by(EIN, fiscal_year, name, version) %>%
  # dplyr::mutate(n = dplyr::n(), .groups = "drop") %>%  
  pivot_wider(names_from = version, values_from = value) %>%
  filter(!is.na(original)) %>%
  filter(recent != original) %>%
  filter(!EIN %in% eins_discord)  %>% nrow() }, 0)


```

# Save Results

```{r}

# add variables that don't have values across multiple years

 endowment_recent_long %>% 
  select(-version) %>%
   pivot_wider(names_from = name,
               values_from = value) %>%
  left_join(add_vars) %>%
  saveRDS(here("data", "endowments_by_most_recent_filings.RDS"))




```







